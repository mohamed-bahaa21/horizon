{"ast":null,"code":"import crypto from 'crypto';\nimport { v4, v5, validate } from 'uuid';\nimport bcrypt from 'bcryptjs';\nimport { JWT, JWE, JWK } from 'jose';\nimport { startOfMonth } from 'date-fns';\nconst SALT_ROUNDS = 10;\nconst KEY = JWK.asKey(Buffer.from(secret()));\nconst ROTATING_SALT = hash(startOfMonth(new Date()).toUTCString());\nconst CHARS = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\nexport function hash(...args) {\n  return crypto.createHash('sha512').update(args.join('')).digest('hex');\n}\nexport function secret() {\n  return hash(process.env.HASH_SALT);\n}\nexport function salt() {\n  return v5([secret(), ROTATING_SALT].join(''), v5.DNS);\n}\nexport function uuid(...args) {\n  if (!args.length) return v4();\n  return v5(args.join(''), salt());\n}\nexport function isValidUuid(s) {\n  return validate(s);\n}\nexport function getRandomChars(n) {\n  let s = '';\n\n  for (let i = 0; i < n; i++) {\n    s += CHARS[Math.floor(Math.random() * CHARS.length)];\n  }\n\n  return s;\n}\nexport function hashPassword(password) {\n  return bcrypt.hashSync(password, SALT_ROUNDS);\n}\nexport function checkPassword(password, hash) {\n  return bcrypt.compareSync(password, hash);\n}\nexport async function createToken(payload) {\n  return JWT.sign(payload, KEY);\n}\nexport async function parseToken(token) {\n  try {\n    return JWT.verify(token, KEY);\n  } catch {\n    return null;\n  }\n}\nexport async function createSecureToken(payload) {\n  return JWE.encrypt(await createToken(payload), KEY);\n}\nexport async function parseSecureToken(token) {\n  try {\n    const result = await JWE.decrypt(token, KEY);\n    return parseToken(result.toString());\n  } catch {\n    return null;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}