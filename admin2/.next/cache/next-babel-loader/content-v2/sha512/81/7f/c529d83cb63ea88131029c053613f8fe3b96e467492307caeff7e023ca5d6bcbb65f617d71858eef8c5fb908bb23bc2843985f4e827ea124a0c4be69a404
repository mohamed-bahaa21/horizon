{"ast":null,"code":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport moment from 'moment-timezone';\nimport prisma from 'lib/db';\nimport { subMinutes } from 'date-fns';\nimport { MYSQL, POSTGRESQL, MYSQL_DATE_FORMATS, POSTGRESQL_DATE_FORMATS, URL_LENGTH } from 'lib/constants';\nexport function getDatabase() {\n  const type = process.env.DATABASE_TYPE || process.env.DATABASE_URL && process.env.DATABASE_URL.split(':')[0];\n\n  if (type === 'postgres') {\n    return 'postgresql';\n  }\n\n  return type;\n}\nexport async function runQuery(query) {\n  return query.catch(e => {\n    throw e;\n  });\n}\nexport async function rawQuery(query, params = []) {\n  const db = getDatabase();\n\n  if (db !== POSTGRESQL && db !== MYSQL) {\n    return Promise.reject(new Error('Unknown database.'));\n  }\n\n  const sql = db === MYSQL ? query.replace(/\\$[0-9]+/g, '?') : query;\n  return prisma.$queryRaw.apply(prisma, [sql, ...params]);\n}\nexport function getDateQuery(field, unit, timezone) {\n  const db = getDatabase();\n\n  if (db === POSTGRESQL) {\n    if (timezone) {\n      return `to_char(date_trunc('${unit}', ${field} at time zone '${timezone}'), '${POSTGRESQL_DATE_FORMATS[unit]}')`;\n    }\n\n    return `to_char(date_trunc('${unit}', ${field}), '${POSTGRESQL_DATE_FORMATS[unit]}')`;\n  }\n\n  if (db === MYSQL) {\n    if (timezone) {\n      const tz = moment.tz(timezone).format('Z');\n      return `DATE_FORMAT(convert_tz(${field},'+00:00','${tz}'), '${MYSQL_DATE_FORMATS[unit]}')`;\n    }\n\n    return `DATE_FORMAT(${field}, '${MYSQL_DATE_FORMATS[unit]}')`;\n  }\n}\nexport function getTimestampInterval(field) {\n  const db = getDatabase();\n\n  if (db === POSTGRESQL) {\n    return `floor(extract(epoch from max(${field}) - min(${field})))`;\n  }\n\n  if (db === MYSQL) {\n    return `floor(unix_timestamp(max(${field})) - unix_timestamp(min(${field})))`;\n  }\n}\nexport async function getWebsiteById(website_id) {\n  return runQuery(prisma.website.findUnique({\n    where: {\n      website_id\n    }\n  }));\n}\nexport async function getWebsiteByUuid(website_uuid) {\n  return runQuery(prisma.website.findUnique({\n    where: {\n      website_uuid\n    }\n  }));\n}\nexport async function getWebsiteByShareId(share_id) {\n  return runQuery(prisma.website.findUnique({\n    where: {\n      share_id\n    }\n  }));\n}\nexport async function getUserWebsites(user_id) {\n  return runQuery(prisma.website.findMany({\n    where: {\n      user_id\n    },\n    orderBy: {\n      name: 'asc'\n    }\n  }));\n}\nexport async function createWebsite(user_id, data) {\n  return runQuery(prisma.website.create({\n    data: _objectSpread({\n      account: {\n        connect: {\n          user_id\n        }\n      }\n    }, data)\n  }));\n}\nexport async function updateWebsite(website_id, data) {\n  return runQuery(prisma.website.update({\n    where: {\n      website_id\n    },\n    data\n  }));\n}\nexport async function resetWebsite(website_id) {\n  return runQuery(prisma.$queryRaw`delete from session where website_id=${website_id}`);\n}\nexport async function deleteWebsite(website_id) {\n  return runQuery(\n  /* Prisma bug, does not cascade on non-nullable foreign keys\r\n  prisma.website.delete({\r\n    where: {\r\n      website_id,\r\n    },\r\n  }),\r\n   */\n  prisma.$queryRaw`delete from website where website_id=${website_id}`);\n}\nexport async function createSession(website_id, data) {\n  return runQuery(prisma.session.create({\n    data: _objectSpread({\n      website_id\n    }, data),\n    select: {\n      session_id: true\n    }\n  }));\n}\nexport async function getSessionByUuid(session_uuid) {\n  return runQuery(prisma.session.findUnique({\n    where: {\n      session_uuid\n    }\n  }));\n}\nexport async function savePageView(website_id, session_id, url, referrer) {\n  return runQuery(prisma.pageview.create({\n    data: {\n      website_id,\n      session_id,\n      url: url === null || url === void 0 ? void 0 : url.substr(0, URL_LENGTH),\n      referrer: referrer === null || referrer === void 0 ? void 0 : referrer.substr(0, URL_LENGTH)\n    }\n  }));\n}\nexport async function saveEvent(website_id, session_id, url, event_type, event_value) {\n  return runQuery(prisma.event.create({\n    data: {\n      website_id,\n      session_id,\n      url: url === null || url === void 0 ? void 0 : url.substr(0, URL_LENGTH),\n      event_type: event_type === null || event_type === void 0 ? void 0 : event_type.substr(0, 50),\n      event_value: event_value === null || event_value === void 0 ? void 0 : event_value.substr(0, 50)\n    }\n  }));\n}\nexport async function getAccounts() {\n  return runQuery(prisma.account.findMany());\n}\nexport async function getAccountById(user_id) {\n  return runQuery(prisma.account.findUnique({\n    where: {\n      user_id\n    }\n  }));\n}\nexport async function getAccountByUsername(username) {\n  return runQuery(prisma.account.findUnique({\n    where: {\n      username\n    }\n  }));\n}\nexport async function updateAccount(user_id, data) {\n  return runQuery(prisma.account.update({\n    where: {\n      user_id\n    },\n    data\n  }));\n}\nexport async function deleteAccount(user_id) {\n  return runQuery(\n  /* Prisma bug, does not cascade on non-nullable foreign keys\r\n  prisma.account.delete({\r\n    where: {\r\n      user_id,\r\n    },\r\n  }),\r\n   */\n  prisma.$queryRaw`delete from account where user_id=${user_id}`);\n}\nexport async function createAccount(data) {\n  return runQuery(prisma.account.create({\n    data\n  }));\n}\nexport async function getSessions(websites, start_at) {\n  return runQuery(prisma.session.findMany({\n    where: {\n      website: {\n        website_id: {\n          in: websites\n        }\n      },\n      created_at: {\n        gte: start_at\n      }\n    }\n  }));\n}\nexport async function getPageviews(websites, start_at) {\n  return runQuery(prisma.pageview.findMany({\n    where: {\n      website: {\n        website_id: {\n          in: websites\n        }\n      },\n      created_at: {\n        gte: start_at\n      }\n    }\n  }));\n}\nexport async function getEvents(websites, start_at) {\n  return runQuery(prisma.event.findMany({\n    where: {\n      website: {\n        website_id: {\n          in: websites\n        }\n      },\n      created_at: {\n        gte: start_at\n      }\n    }\n  }));\n}\nexport function getWebsiteStats(website_id, start_at, end_at, filters = {}) {\n  const params = [website_id, start_at, end_at];\n  const {\n    url\n  } = filters;\n  let urlFilter = '';\n\n  if (url) {\n    urlFilter = `and url=$${params.length + 1}`;\n    params.push(decodeURIComponent(url));\n  }\n\n  return rawQuery(`\n      select sum(t.c) as \"pageviews\",\n        count(distinct t.session_id) as \"uniques\",\n        sum(case when t.c = 1 then 1 else 0 end) as \"bounces\",\n        sum(t.time) as \"totaltime\"\n      from (\n         select session_id,\n           ${getDateQuery('created_at', 'hour')},\n           count(*) c,\n           ${getTimestampInterval('created_at')} as \"time\"\n         from pageview\n         where website_id=$1\n         and created_at between $2 and $3\n         ${urlFilter}\n         group by 1, 2\n     ) t\n    `, params);\n}\nexport function getPageviewStats(website_id, start_at, end_at, timezone = 'utc', unit = 'day', count = '*', url) {\n  const params = [website_id, start_at, end_at];\n  let urlFilter = '';\n\n  if (url) {\n    urlFilter = `and url=$${params.length + 1}`;\n    params.push(decodeURIComponent(url));\n  }\n\n  return rawQuery(`\n    select ${getDateQuery('created_at', unit, timezone)} t,\n      count(${count}) y\n    from pageview\n    where website_id=$1\n    and created_at between $2 and $3\n    ${urlFilter}\n    group by 1\n    order by 1\n    `, params);\n}\nexport function getSessionMetrics(website_id, start_at, end_at, field, filters = {}) {\n  const params = [website_id, start_at, end_at];\n  const {\n    url\n  } = filters;\n  let urlFilter = '';\n\n  if (url) {\n    urlFilter = `and url=$${params.length + 1}`;\n    params.push(decodeURIComponent(url));\n  }\n\n  return rawQuery(`\n    select ${field} x, count(*) y\n    from session\n    where session_id in (\n      select session_id\n      from pageview\n      where website_id=$1\n      and created_at between $2 and $3\n      ${urlFilter}\n    )\n    group by 1\n    order by 2 desc\n    `, params);\n}\nexport function getPageviewMetrics(website_id, start_at, end_at, field, table, filters = {}) {\n  const params = [website_id, start_at, end_at];\n  const {\n    domain,\n    url\n  } = filters;\n  let domainFilter = '';\n  let urlFilter = '';\n\n  if (domain) {\n    domainFilter = `and referrer not like $${params.length + 1} and referrer not like '/%'`;\n    params.push(`%://${domain}/%`);\n  }\n\n  if (url) {\n    urlFilter = `and url=$${params.length + 1}`;\n    params.push(decodeURIComponent(url));\n  }\n\n  return rawQuery(`\n    select ${field} x, count(*) y\n    from ${table}\n    where website_id=$1\n    and created_at between $2 and $3\n    ${domainFilter}\n    ${urlFilter}\n    group by 1\n    order by 2 desc\n    `, params);\n}\nexport function getActiveVisitors(website_id) {\n  const date = subMinutes(new Date(), 5);\n  const params = [website_id, date];\n  return rawQuery(`\n    select count(distinct session_id) x\n    from pageview\n    where website_id=$1\n    and created_at >= $2\n    `, params);\n}\nexport function getEventMetrics(website_id, start_at, end_at, timezone = 'utc', unit = 'day', filters = {}) {\n  const params = [website_id, start_at, end_at];\n  const {\n    url,\n    event_type\n  } = filters;\n  let urlFilter = '';\n  let eventTypeFilter = '';\n\n  if (url) {\n    urlFilter = `and url=$${params.length + 1}`;\n    params.push(decodeURIComponent(url));\n  }\n\n  if (event_type) {\n    eventTypeFilter = `and event_type=$${params.length + 1}`;\n    params.push(event_type);\n  }\n\n  return rawQuery(`\n    select\n      event_value x,\n      ${getDateQuery('created_at', unit, timezone)} t,\n      count(*) y\n    from event\n    where website_id=$1\n    and created_at between $2 and $3\n    ${urlFilter}\n    ${eventTypeFilter}\n    group by 1, 2\n    order by 2\n    `, params);\n}\nexport async function getRealtimeData(websites, time) {\n  const [pageviews, sessions, events] = await Promise.all([getPageviews(websites, time), getSessions(websites, time), getEvents(websites, time)]);\n  return {\n    pageviews: pageviews.map((_ref) => {\n      let {\n        view_id\n      } = _ref,\n          props = _objectWithoutProperties(_ref, [\"view_id\"]);\n\n      return _objectSpread({\n        __id: `p${view_id}`,\n        view_id\n      }, props);\n    }),\n    sessions: sessions.map((_ref2) => {\n      let {\n        session_id\n      } = _ref2,\n          props = _objectWithoutProperties(_ref2, [\"session_id\"]);\n\n      return _objectSpread({\n        __id: `s${session_id}`,\n        session_id\n      }, props);\n    }),\n    events: events.map((_ref3) => {\n      let {\n        event_id\n      } = _ref3,\n          props = _objectWithoutProperties(_ref3, [\"event_id\"]);\n\n      return _objectSpread({\n        __id: `e${event_id}`,\n        event_id\n      }, props);\n    }),\n    timestamp: Date.now()\n  };\n}","map":null,"metadata":{},"sourceType":"module"}